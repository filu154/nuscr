<!doctype html><html xmlns=http://www.w3.org/1999/xhtml><title>Gtype (nuscr.Nuscrlib.Gtype)</title><link rel=stylesheet href=../../../odoc.support/odoc.css><meta charset=utf-8><meta name=generator content="odoc 2.2.1"><meta name=viewport content="width=device-width,initial-scale=1"><script src=../../../odoc.support/highlight.pack.js></script><script>hljs.initHighlightingOnLoad()</script><body class=odoc><nav class=odoc-nav><a href=../index.html>Up</a> â€“ <a href=../../index.html>nuscr</a> &#x00BB; <a href=../index.html>Nuscrlib</a> &#x00BB; Gtype</nav><header class=odoc-preamble><h1>Module <code><span>Nuscrlib.Gtype</span></code></h1><p>Global types</header><div class=odoc-content><div class=odoc-spec><div class="spec type anchored" id=type-scr_module><a href=#type-scr_module class=anchor></a><code><span><span class=keyword>type</span> scr_module</span></code></div></div><div class=odoc-spec><div class="spec type anchored" id=type-global_protocol><a href=#type-global_protocol class=anchor></a><code><span><span class=keyword>type</span> global_protocol</span><span> = <span><span class=xref-unresolved>Nuscrlib__.Syntax.raw_global_protocol</span> <a href=../Loc/index.html#type-located>Loc.located</a></span></span></code></div></div><div class=odoc-spec><div class="spec type anchored" id=type-rec_var><a href=#type-rec_var class=anchor></a><code><span><span class=keyword>type</span> rec_var</span><span> = </span><span>{</span></code><ol><li id=type-rec_var.rv_name class="def record field anchored"><a href=#type-rec_var.rv_name class=anchor></a><code><span>rv_name : <a href=../Names/VariableName/index.html#type-t>Names.VariableName.t</a>;</span></code><div class=def-doc><span class=comment-delim>(*</span><p>Variable Name</p><span class=comment-delim>*)</span></div><li id=type-rec_var.rv_roles class="def record field anchored"><a href=#type-rec_var.rv_roles class=anchor></a><code><span>rv_roles : <span><a href=../Names/RoleName/index.html#type-t>Names.RoleName.t</a> <span class=xref-unresolved>Base</span>.list</span>;</span></code><div class=def-doc><span class=comment-delim>(*</span><p>Which roles know this variable</p><span class=comment-delim>*)</span></div><li id=type-rec_var.rv_ty class="def record field anchored"><a href=#type-rec_var.rv_ty class=anchor></a><code><span>rv_ty : <a href=../Expr/index.html#type-payload_type>Expr.payload_type</a>;</span></code><div class=def-doc><span class=comment-delim>(*</span><p>What type does the variable carry</p><span class=comment-delim>*)</span></div><li id=type-rec_var.rv_init_expr class="def record field anchored"><a href=#type-rec_var.rv_init_expr class=anchor></a><code><span>rv_init_expr : <a href=../Expr/index.html#type-t>Expr.t</a>;</span></code><div class=def-doc><span class=comment-delim>(*</span><p>What is the initial expression assigned at the beginning of recursion</p><span class=comment-delim>*)</span></div></ol><code><span>}</span></code></div><div class=spec-doc><p>Recursion variable</div></div><div class=odoc-spec><div class="spec value anchored" id=val-equal_rec_var><a href=#val-equal_rec_var class=anchor></a><code><span><span class=keyword>val</span> equal_rec_var : <span><a href=#type-rec_var>rec_var</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-rec_var>rec_var</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.bool</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-pp_rec_var><a href=#val-pp_rec_var class=anchor></a><code><span><span class=keyword>val</span> pp_rec_var : <span><span class=xref-unresolved>Ppx_deriving_runtime</span>.Format.formatter <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-rec_var>rec_var</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.unit</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-show_rec_var><a href=#val-show_rec_var class=anchor></a><code><span><span class=keyword>val</span> show_rec_var : <span><a href=#type-rec_var>rec_var</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.string</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-sexp_of_rec_var><a href=#val-sexp_of_rec_var class=anchor></a><code><span><span class=keyword>val</span> sexp_of_rec_var : <span><a href=#type-rec_var>rec_var</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Sexplib0</span>.Sexp.t</span></code></div></div><div class=odoc-spec><div class="spec type anchored" id=type-t><a href=#type-t class=anchor></a><code><span><span class=keyword>type</span> t</span><span> =</span></code><ol><li id=type-t.MuG class="def variant constructor anchored"><a href=#type-t.MuG class=anchor></a><code><span>| </span><span><span class=constructor>MuG</span> <span class=keyword>of</span> <a href=../Names/TypeVariableName/index.html#type-t>Names.TypeVariableName.t</a> * <span><a href=#type-rec_var>rec_var</a> <span class=xref-unresolved>Base</span>.list</span> * <a href=#type-t>t</a></span></code><div class=def-doc><span class=comment-delim>(*</span><p><code>MuG (type_var, rec_vars, g)</code> is a recursive type, corresponding to the syntax `\mu t. G`, where t is represented by <code>type_var</code> and G is represented by <code>t</code>. <code>rec_vars</code> are recursion parameters, used in RefinementTypes extension for parameterised recursion, an empty list is supplied when that feature is not used.</p><span class=comment-delim>*)</span></div><li id=type-t.TVarG class="def variant constructor anchored"><a href=#type-t.TVarG class=anchor></a><code><span>| </span><span><span class=constructor>TVarG</span> <span class=keyword>of</span> <a href=../Names/TypeVariableName/index.html#type-t>Names.TypeVariableName.t</a> * <span><a href=../Expr/index.html#type-t>Expr.t</a> <span class=xref-unresolved>Base</span>.list</span> * <span><a href=#type-t>t</a> <span class=xref-unresolved>Base</span>.Lazy.t</span></span></code><div class=def-doc><span class=comment-delim>(*</span><p><code>TVarG (type_var, exprs, g_lazy)</code> is a type variable, scoped inside a recursion. <code>type_var</code> is the name of the type variable, <code>exprs</code> are expressions supplied into paramterised recursion, used in RefinementTypes extension. Otherwise an empty list is supplied when that feature is not used. <code>g_lazy</code> provides a convenient way to access the type that the type variable recurses into.</p><span class=comment-delim>*)</span></div><li id=type-t.ChoiceG class="def variant constructor anchored"><a href=#type-t.ChoiceG class=anchor></a><code><span>| </span><span><span class=constructor>ChoiceG</span> <span class=keyword>of</span> <a href=../Names/RoleName/index.html#type-t>Names.RoleName.t</a> * <span><a href=#type-t>t</a> <span class=xref-unresolved>Base</span>.list</span></span></code><div class=def-doc><span class=comment-delim>(*</span><p><code>ChoiceG (name, ts)</code> expresses a choice located at participant <code>name</code> between the <code>ts</code></p><span class=comment-delim>*)</span></div><li id=type-t.EndG class="def variant constructor anchored"><a href=#type-t.EndG class=anchor></a><code><span>| </span><span><span class=constructor>EndG</span></span></code><div class=def-doc><span class=comment-delim>(*</span><p>Empty global type</p><span class=comment-delim>*)</span></div><li id=type-t.CallG class="def variant constructor anchored"><a href=#type-t.CallG class=anchor></a><code><span>| </span><span><span class=constructor>CallG</span> <span class=keyword>of</span> <a href=../Names/RoleName/index.html#type-t>Names.RoleName.t</a> * <a href=../Names/ProtocolName/index.html#type-t>Names.ProtocolName.t</a> * <span><a href=../Names/RoleName/index.html#type-t>Names.RoleName.t</a> <span class=xref-unresolved>Base</span>.list</span> * <a href=#type-t>t</a></span></code><div class=def-doc><span class=comment-delim>(*</span><p><code>CallG (caller, protocol, participants, t)</code> - <code>caller</code> calls <code>protocol</code>, inviting <code>participants</code> to carry out the roles in <code>protocol</code> (dynamic roles in nested protocols are not included)</p><span class=comment-delim>*)</span></div></ol></div><div class=spec-doc><p>The type of global types. See also <a href=../LiteratureSyntax/index.html#type-global><code>LiteratureSyntax.global</code></a> for a simpler syntax.</div></div><div class=odoc-spec><div class="spec value anchored" id=val-pp><a href=#val-pp class=anchor></a><code><span><span class=keyword>val</span> pp : <span><span class=xref-unresolved>Ppx_deriving_runtime</span>.Format.formatter <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.unit</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-show><a href=#val-show class=anchor></a><code><span><span class=keyword>val</span> show : <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.string</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-sexp_of_t><a href=#val-sexp_of_t class=anchor></a><code><span><span class=keyword>val</span> sexp_of_t : <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Sexplib0</span>.Sexp.t</span></code></div></div><p>Mapping of protocol name to the roles ('static' participants, dynamic participants) participating in the protocol, the names of the nested protocols defined inside it and its global type<div class=odoc-spec><div class="spec type anchored" id=type-nested_global_info><a href=#type-nested_global_info class=anchor></a><code><span><span class=keyword>type</span> nested_global_info</span><span> = </span><span>{</span></code><ol><li id=type-nested_global_info.static_roles class="def record field anchored"><a href=#type-nested_global_info.static_roles class=anchor></a><code><span>static_roles : <span><a href=../Names/RoleName/index.html#type-t>Names.RoleName.t</a> <span class=xref-unresolved>Base</span>.list</span>;</span></code><li id=type-nested_global_info.dynamic_roles class="def record field anchored"><a href=#type-nested_global_info.dynamic_roles class=anchor></a><code><span>dynamic_roles : <span><a href=../Names/RoleName/index.html#type-t>Names.RoleName.t</a> <span class=xref-unresolved>Base</span>.list</span>;</span></code><li id=type-nested_global_info.nested_protocol_names class="def record field anchored"><a href=#type-nested_global_info.nested_protocol_names class=anchor></a><code><span>nested_protocol_names : <span><a href=../Names/ProtocolName/index.html#type-t>Names.ProtocolName.t</a> <span class=xref-unresolved>Base</span>.list</span>;</span></code><li id=type-nested_global_info.gtype class="def record field anchored"><a href=#type-nested_global_info.gtype class=anchor></a><code><span>gtype : <a href=#type-t>t</a>;</span></code></ol><code><span>}</span></code></div></div><div class=odoc-spec><div class="spec type anchored" id=type-nested_t><a href=#type-nested_t class=anchor></a><code><span><span class=keyword>type</span> nested_t</span><span> = <span><a href=#type-nested_global_info>nested_global_info</a> <span class=xref-unresolved>Base</span>.Map.M(<span class=xref-unresolved>Nuscrlib__</span>.Names.ProtocolName).t</span></span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-show_nested_t><a href=#val-show_nested_t class=anchor></a><code><span><span class=keyword>val</span> show_nested_t : <span><a href=#type-nested_t>nested_t</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Base</span>.string</span></code></div><div class=spec-doc><p>Provides a textual representation of a global type with nested protocols</div></div><div class=odoc-spec><div class="spec value anchored" id=val-call_label><a href=#val-call_label class=anchor></a><code><span><span class=keyword>val</span> call_label : <span><a href=../Names/RoleName/index.html#type-t>Names.RoleName.t</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=../Names/ProtocolName/index.html#type-t>Names.ProtocolName.t</a> <span class=arrow>&#45;&gt;</span></span> <span><span><a href=../Names/RoleName/index.html#type-t>Names.RoleName.t</a> <span class=xref-unresolved>Base</span>.list</span> <span class=arrow>&#45;&gt;</span></span> <a href=../Names/LabelName/index.html#type-t>Names.LabelName.t</a></span></code></div><div class=spec-doc><p>Generates a unique label for a protocol call based on the caller, the protocol called and the participants involved</div></div><div class=odoc-spec><div class="spec value anchored" id=val-of_protocol><a href=#val-of_protocol class=anchor></a><code><span><span class=keyword>val</span> of_protocol : <span><a href=#type-global_protocol>global_protocol</a> <span class=arrow>&#45;&gt;</span></span> <a href=#type-t>t</a></span></code></div><div class=spec-doc><p>Turn a raw protocol (from the parser) into a global type.</div></div><div class=odoc-spec><div class="spec value anchored" id=val-nested_t_of_module><a href=#val-nested_t_of_module class=anchor></a><code><span><span class=keyword>val</span> nested_t_of_module : <span><a href=#type-scr_module>scr_module</a> <span class=arrow>&#45;&gt;</span></span> <a href=#type-nested_t>nested_t</a></span></code></div><div class=spec-doc><p>Turn scribble module (from the parser) into a nested global type</div></div><div class=odoc-spec><div class="spec value anchored" id=val-normalise><a href=#val-normalise class=anchor></a><code><span><span class=keyword>val</span> normalise : <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <a href=#type-t>t</a></span></code></div><div class=spec-doc><p>Normalise a global type. This mainly collapses nested choice on the same participant and unfolds fixpoints</div></div><div class=odoc-spec><div class="spec value anchored" id=val-normalise_nested_t><a href=#val-normalise_nested_t class=anchor></a><code><span><span class=keyword>val</span> normalise_nested_t : <span><a href=#type-nested_t>nested_t</a> <span class=arrow>&#45;&gt;</span></span> <a href=#type-nested_t>nested_t</a></span></code></div><div class=spec-doc><p>Apply normalisation to all protocols in nested_t</div></div><div class=odoc-spec><div class="spec value anchored" id=val-validate_refinements_exn><a href=#val-validate_refinements_exn class=anchor></a><code><span><span class=keyword>val</span> validate_refinements_exn : <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Base</span>.unit</span></code></div><div class=spec-doc><p>Validate refinements in the given global type, requires <code>RefinementTypes</code> pragma</div></div></div>
