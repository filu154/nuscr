<!doctype html><html xmlns=http://www.w3.org/1999/xhtml><title>Expr (nuscr.Nuscrlib.Expr)</title><link rel=stylesheet href=../../../odoc.support/odoc.css><meta charset=utf-8><meta name=generator content="odoc 2.2.1"><meta name=viewport content="width=device-width,initial-scale=1"><script src=../../../odoc.support/highlight.pack.js></script><script>hljs.initHighlightingOnLoad()</script><body class=odoc><nav class=odoc-nav><a href=../index.html>Up</a> â€“ <a href=../../index.html>nuscr</a> &#x00BB; <a href=../index.html>Nuscrlib</a> &#x00BB; Expr</nav><header class=odoc-preamble><h1>Module <code><span>Nuscrlib.Expr</span></code></h1><p>Expressions, used in <code>RefinementTypes</code> pragma</header><nav class=odoc-toc><ul><li><a href=#expressions>Expressions</a><li><a href=#types>Types</a><li><a href=#typing>Typing</a><li><a href=#smt-interfacing>SMT Interfacing</a></ul></nav><div class=odoc-content><h2 id=expressions><a href=#expressions class=anchor></a>Expressions</h2><div class=odoc-spec><div class="spec type anchored" id=type-t><a href=#type-t class=anchor></a><code><span><span class=keyword>type</span> t</span></code></div><div class=spec-doc><p>An expression, used in RefinementType extension<pre> type t =
   | Var of VariableName.t  (** A variable *)
   | Int of int  (** An integer constant *)
   | Bool of bool  (** An boolean constant *)
   | String of string  (** A string literal *)
   | Binop of binop * t * t  (** A binary operator *)
   | Unop of unop * t  (** An unary operator *)</pre></div></div><div class=odoc-spec><div class="spec value anchored" id=val-equal><a href=#val-equal class=anchor></a><code><span><span class=keyword>val</span> equal : <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.bool</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-compare><a href=#val-compare class=anchor></a><code><span><span class=keyword>val</span> compare : <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.int</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-pp><a href=#val-pp class=anchor></a><code><span><span class=keyword>val</span> pp : <span><span class=xref-unresolved>Ppx_deriving_runtime</span>.Format.formatter <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.unit</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-show><a href=#val-show class=anchor></a><code><span><span class=keyword>val</span> show : <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.string</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-sexp_of_t><a href=#val-sexp_of_t class=anchor></a><code><span><span class=keyword>val</span> sexp_of_t : <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Sexplib0</span>.Sexp.t</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-free_var><a href=#val-free_var class=anchor></a><code><span><span class=keyword>val</span> free_var : <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Base</span>.Set.M(<span class=xref-unresolved>Nuscrlib__</span>.Names.VariableName).t</span></code></div><div class=spec-doc><p>Get free variables in an expression</div></div><div class=odoc-spec><div class="spec value anchored" id=val-substitute><a href=#val-substitute class=anchor></a><code><span><span class=keyword>val</span> substitute : <span>from:<a href=../Names/VariableName/index.html#type-t>Names.VariableName.t</a> <span class=arrow>&#45;&gt;</span></span> <span>replace:<a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <a href=#type-t>t</a></span></code></div><div class=spec-doc><p>Perform substitutions on an expression</div></div><div class=odoc-spec><div class="spec module anchored" id=module-Sexp><a href=#module-Sexp class=anchor></a><code><span><span class=keyword>module</span> <a href=Sexp/index.html>Sexp</a></span><span> : <span class=keyword>sig</span> ... <span class=keyword>end</span></span></code></div><div class=spec-doc><p>An modified S-expression library that distinguishes literal strings and * atoms</div></div><div class=odoc-spec><div class="spec value anchored" id=val-sexp_of_expr><a href=#val-sexp_of_expr class=anchor></a><code><span><span class=keyword>val</span> sexp_of_expr : <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <a href=Sexp/index.html#type-t>Sexp.t</a></span></code></div><div class=spec-doc><p>Convert an expression to S-expression</div></div><h2 id=types><a href=#types class=anchor></a>Types</h2><div class=odoc-spec><div class="spec type anchored" id=type-payload_type><a href=#type-payload_type class=anchor></a><code><span><span class=keyword>type</span> payload_type</span><span> =</span></code><ol><li id=type-payload_type.PTInt class="def variant constructor anchored"><a href=#type-payload_type.PTInt class=anchor></a><code><span>| </span><span><span class=constructor>PTInt</span></span></code><div class=def-doc><span class=comment-delim>(*</span><p>A type for integers</p><span class=comment-delim>*)</span></div><li id=type-payload_type.PTBool class="def variant constructor anchored"><a href=#type-payload_type.PTBool class=anchor></a><code><span>| </span><span><span class=constructor>PTBool</span></span></code><div class=def-doc><span class=comment-delim>(*</span><p>A type for booleans</p><span class=comment-delim>*)</span></div><li id=type-payload_type.PTString class="def variant constructor anchored"><a href=#type-payload_type.PTString class=anchor></a><code><span>| </span><span><span class=constructor>PTString</span></span></code><div class=def-doc><span class=comment-delim>(*</span><p>A type for strings</p><span class=comment-delim>*)</span></div><li id=type-payload_type.PTUnit class="def variant constructor anchored"><a href=#type-payload_type.PTUnit class=anchor></a><code><span>| </span><span><span class=constructor>PTUnit</span></span></code><div class=def-doc><span class=comment-delim>(*</span><p>A type for units</p><span class=comment-delim>*)</span></div><li id=type-payload_type.PTAbstract class="def variant constructor anchored"><a href=#type-payload_type.PTAbstract class=anchor></a><code><span>| </span><span><span class=constructor>PTAbstract</span> <span class=keyword>of</span> <a href=../Names/PayloadTypeName/index.html#type-t>Names.PayloadTypeName.t</a></span></code><div class=def-doc><span class=comment-delim>(*</span><p>A type for other un-modelled payloads, e.g. custom types</p><span class=comment-delim>*)</span></div><li id=type-payload_type.PTRefined class="def variant constructor anchored"><a href=#type-payload_type.PTRefined class=anchor></a><code><span>| </span><span><span class=constructor>PTRefined</span> <span class=keyword>of</span> <a href=../Names/VariableName/index.html#type-t>Names.VariableName.t</a> * <a href=#type-payload_type>payload_type</a> * <a href=#type-t>t</a></span></code><div class=def-doc><span class=comment-delim>(*</span><p>A refined types, <code>PTRefined (x, ty, e)</code> stands for the refined type 'x:ty{e}' where <code>e</code> is a predicate on <code>x</code>.</p><span class=comment-delim>*)</span></div></ol></div><div class=spec-doc><p>Types for expressions. Integers, booleans and strings are are modelled, and can be thus refined with RefinementTypes extension</div></div><div class=odoc-spec><div class="spec value anchored" id=val-equal_payload_type><a href=#val-equal_payload_type class=anchor></a><code><span><span class=keyword>val</span> equal_payload_type : <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.bool</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-compare_payload_type><a href=#val-compare_payload_type class=anchor></a><code><span><span class=keyword>val</span> compare_payload_type : <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.int</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-pp_payload_type><a href=#val-pp_payload_type class=anchor></a><code><span><span class=keyword>val</span> pp_payload_type : <span><span class=xref-unresolved>Ppx_deriving_runtime</span>.Format.formatter <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.unit</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-show_payload_type><a href=#val-show_payload_type class=anchor></a><code><span><span class=keyword>val</span> show_payload_type : <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Ppx_deriving_runtime</span>.string</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-sexp_of_payload_type><a href=#val-sexp_of_payload_type class=anchor></a><code><span><span class=keyword>val</span> sexp_of_payload_type : <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Sexplib0</span>.Sexp.t</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-payload_typename_of_payload_type><a href=#val-payload_typename_of_payload_type class=anchor></a><code><span><span class=keyword>val</span> payload_typename_of_payload_type : <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <a href=../Names/PayloadTypeName/index.html#type-t>Names.PayloadTypeName.t</a></span></code></div><div class=spec-doc><p>Extract <code>PayloadTypeName</code> from a <code>payload_type</code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-smt_sort_of_type><a href=#val-smt_sort_of_type class=anchor></a><code><span><span class=keyword>val</span> smt_sort_of_type : <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Base</span>.string</span></code></div><div class=spec-doc><p>Get the SMT sort of a <code>payload_type</code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-default_value><a href=#val-default_value class=anchor></a><code><span><span class=keyword>val</span> default_value : <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <a href=#type-t>t</a></span></code></div><div class=spec-doc><p>Get the default value of a payload type, which may not exist.</div></div><div class=odoc-spec><div class="spec value anchored" id=val-parse_typename><a href=#val-parse_typename class=anchor></a><code><span><span class=keyword>val</span> parse_typename : <span><a href=../Names/PayloadTypeName/index.html#type-t>Names.PayloadTypeName.t</a> <span class=arrow>&#45;&gt;</span></span> <a href=#type-payload_type>payload_type</a></span></code></div><div class=spec-doc><p>Convert a PayloadTypeName to a <code>payload_type</code></div></div><h2 id=typing><a href=#typing class=anchor></a>Typing</h2><div class=odoc-spec><div class="spec type anchored" id=type-typing_env><a href=#type-typing_env class=anchor></a><code><span><span class=keyword>type</span> typing_env</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-new_typing_env><a href=#val-new_typing_env class=anchor></a><code><span><span class=keyword>val</span> new_typing_env : <a href=#type-typing_env>typing_env</a></span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-is_well_formed_type><a href=#val-is_well_formed_type class=anchor></a><code><span><span class=keyword>val</span> is_well_formed_type : <span><a href=#type-typing_env>typing_env</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Base</span>.bool</span></code></div><div class=spec-doc><p>Check whether a payload type is well-formed under the typing context</div></div><div class=odoc-spec><div class="spec value anchored" id=val-ensure_satisfiable><a href=#val-ensure_satisfiable class=anchor></a><code><span><span class=keyword>val</span> ensure_satisfiable : <span><a href=#type-typing_env>typing_env</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Base</span>.unit</span></code></div><div class=spec-doc><p>Validate whether the typing context is satisfiable, i.e. it does not contain in consistencies</div></div><div class=odoc-spec><div class="spec value anchored" id=val-env_append><a href=#val-env_append class=anchor></a><code><span><span class=keyword>val</span> env_append : <span><a href=#type-typing_env>typing_env</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=../Names/VariableName/index.html#type-t>Names.VariableName.t</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <a href=#type-typing_env>typing_env</a></span></code></div><div class=spec-doc><p>Append an new entry into typing context</div></div><div class=odoc-spec><div class="spec value anchored" id=val-check_type><a href=#val-check_type class=anchor></a><code><span><span class=keyword>val</span> check_type : <span><a href=#type-typing_env>typing_env</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-t>t</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-payload_type>payload_type</a> <span class=arrow>&#45;&gt;</span></span> <span class=xref-unresolved>Base</span>.bool</span></code></div><div class=spec-doc><p>Check whether an expression can be assigned a provided type under a typing context</div></div><h2 id=smt-interfacing><a href=#smt-interfacing class=anchor></a>SMT Interfacing</h2><div class=odoc-spec><div class="spec type anchored" id=type-smt_script><a href=#type-smt_script class=anchor></a><code><span><span class=keyword>type</span> smt_script</span></code></div></div><div class=odoc-spec><div class="spec value anchored" id=val-add_assert_s_expr><a href=#val-add_assert_s_expr class=anchor></a><code><span><span class=keyword>val</span> add_assert_s_expr : <span><a href=Sexp/index.html#type-t>Sexp.t</a> <span class=arrow>&#45;&gt;</span></span> <span><a href=#type-smt_script>smt_script</a> <span class=arrow>&#45;&gt;</span></span> <a href=#type-smt_script>smt_script</a></span></code></div><div class=spec-doc><p>Add an assertion into a SMT script</div></div><div class=odoc-spec><div class="spec value anchored" id=val-encode_env><a href=#val-encode_env class=anchor></a><code><span><span class=keyword>val</span> encode_env : <span><a href=#type-typing_env>typing_env</a> <span class=arrow>&#45;&gt;</span></span> <a href=#type-smt_script>smt_script</a></span></code></div><div class=spec-doc><p>Encode a typing context into a SMT script</div></div><div class=odoc-spec><div class="spec value anchored" id=val-check_sat><a href=#val-check_sat class=anchor></a><code><span><span class=keyword>val</span> check_sat : <span><a href=#type-smt_script>smt_script</a> <span class=arrow>&#45;&gt;</span></span> <span>[ `Sat <span>| `Unsat</span> <span>| `Unknown</span> ]</span></span></code></div><div class=spec-doc><p>Invoke SMT solver on an SMT script</div></div></div>
