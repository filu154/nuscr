<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Expr (nuscr.Nuscrlib.Expr)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">nuscr</a> &#x00BB; <a href="../index.html">Nuscrlib</a> &#x00BB; Expr</nav><header class="odoc-preamble"><h1>Module <code><span>Nuscrlib.Expr</span></code></h1><p>Expressions, used in <code>RefinementTypes</code> pragma</p></header><nav class="odoc-toc"><ul><li><a href="#expressions">Expressions</a></li><li><a href="#types">Types</a></li><li><a href="#typing">Typing</a></li><li><a href="#smt-interfacing">SMT Interfacing</a></li></ul></nav><div class="odoc-content"><h2 id="expressions"><a href="#expressions" class="anchor"></a>Expressions</h2><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>An expression, used in RefinementType extension</p><pre> type t =
   | Var of VariableName.t  (** A variable *)
   | Int of int  (** An integer constant *)
   | Bool of bool  (** An boolean constant *)
   | String of string  (** A string literal *)
   | Binop of binop * t * t  (** A binary operator *)
   | Unop of unop * t  (** An unary operator *)</pre></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-show" class="anchored"><a href="#val-show" class="anchor"></a><code><span><span class="keyword">val</span> show : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-free_var" class="anchored"><a href="#val-free_var" class="anchor"></a><code><span><span class="keyword">val</span> free_var : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.Set.M(<span class="xref-unresolved">Nuscrlib__</span>.Names.VariableName).t</span></code></div><div class="spec-doc"><p>Get free variables in an expression</p></div></div><div class="odoc-spec"><div class="spec value" id="val-substitute" class="anchored"><a href="#val-substitute" class="anchor"></a><code><span><span class="keyword">val</span> substitute : <span>from:<a href="../Names/VariableName/index.html#type-t">Names.VariableName.t</a> <span class="arrow">&#45;&gt;</span></span> <span>replace:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Perform substitutions on an expression</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Sexp" class="anchored"><a href="#module-Sexp" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Sexp/index.html">Sexp</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An modified S-expression library that distinguishes literal strings and * atoms</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_expr" class="anchored"><a href="#val-sexp_of_expr" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_expr : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Sexp/index.html#type-t">Sexp.t</a></span></code></div><div class="spec-doc"><p>Convert an expression to S-expression</p></div></div><h2 id="types"><a href="#types" class="anchor"></a>Types</h2><div class="odoc-spec"><div class="spec type" id="type-payload_type" class="anchored"><a href="#type-payload_type" class="anchor"></a><code><span><span class="keyword">type</span> payload_type</span><span> = </span></code><table><tr id="type-payload_type.PTInt" class="anchored"><td class="def variant constructor"><a href="#type-payload_type.PTInt" class="anchor"></a><code><span>| </span><span><span class="constructor">PTInt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A type for integers</p><span class="comment-delim">*)</span></td></tr><tr id="type-payload_type.PTBool" class="anchored"><td class="def variant constructor"><a href="#type-payload_type.PTBool" class="anchor"></a><code><span>| </span><span><span class="constructor">PTBool</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A type for booleans</p><span class="comment-delim">*)</span></td></tr><tr id="type-payload_type.PTString" class="anchored"><td class="def variant constructor"><a href="#type-payload_type.PTString" class="anchor"></a><code><span>| </span><span><span class="constructor">PTString</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A type for strings</p><span class="comment-delim">*)</span></td></tr><tr id="type-payload_type.PTUnit" class="anchored"><td class="def variant constructor"><a href="#type-payload_type.PTUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">PTUnit</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A type for units</p><span class="comment-delim">*)</span></td></tr><tr id="type-payload_type.PTAbstract" class="anchored"><td class="def variant constructor"><a href="#type-payload_type.PTAbstract" class="anchor"></a><code><span>| </span><span><span class="constructor">PTAbstract</span> <span class="keyword">of</span> <a href="../Names/PayloadTypeName/index.html#type-t">Names.PayloadTypeName.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A type for other un-modelled payloads, e.g. custom types</p><span class="comment-delim">*)</span></td></tr><tr id="type-payload_type.PTRefined" class="anchored"><td class="def variant constructor"><a href="#type-payload_type.PTRefined" class="anchor"></a><code><span>| </span><span><span class="constructor">PTRefined</span> <span class="keyword">of</span> <a href="../Names/VariableName/index.html#type-t">Names.VariableName.t</a> * <a href="#type-payload_type">payload_type</a> * <a href="#type-t">t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A refined types, <code>PTRefined (x, ty, e)</code> stands for the refined type 'x:ty{e}' where <code>e</code> is a predicate on <code>x</code>.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Types for expressions. Integers, booleans and strings are are modelled, and can be thus refined with RefinementTypes extension</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_payload_type" class="anchored"><a href="#val-equal_payload_type" class="anchor"></a><code><span><span class="keyword">val</span> equal_payload_type : 
  <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_payload_type" class="anchored"><a href="#val-compare_payload_type" class="anchor"></a><code><span><span class="keyword">val</span> compare_payload_type : 
  <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_payload_type" class="anchored"><a href="#val-sexp_of_payload_type" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_payload_type : <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-show_payload_type" class="anchored"><a href="#val-show_payload_type" class="anchor"></a><code><span><span class="keyword">val</span> show_payload_type : <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-payload_typename_of_payload_type" class="anchored"><a href="#val-payload_typename_of_payload_type" class="anchor"></a><code><span><span class="keyword">val</span> payload_typename_of_payload_type : <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Names/PayloadTypeName/index.html#type-t">Names.PayloadTypeName.t</a></span></code></div><div class="spec-doc"><p>Extract <code>PayloadTypeName</code> from a <code>payload_type</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-smt_sort_of_type" class="anchored"><a href="#val-smt_sort_of_type" class="anchor"></a><code><span><span class="keyword">val</span> smt_sort_of_type : <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Get the SMT sort of a <code>payload_type</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-default_value" class="anchored"><a href="#val-default_value" class="anchor"></a><code><span><span class="keyword">val</span> default_value : <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Get the default value of a payload type, which may not exist.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-parse_typename" class="anchored"><a href="#val-parse_typename" class="anchor"></a><code><span><span class="keyword">val</span> parse_typename : <span><a href="../Names/PayloadTypeName/index.html#type-t">Names.PayloadTypeName.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-payload_type">payload_type</a></span></code></div><div class="spec-doc"><p>Convert a PayloadTypeName to a <code>payload_type</code></p></div></div><h2 id="typing"><a href="#typing" class="anchor"></a>Typing</h2><div class="odoc-spec"><div class="spec type" id="type-typing_env" class="anchored"><a href="#type-typing_env" class="anchor"></a><code><span><span class="keyword">type</span> typing_env</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-new_typing_env" class="anchored"><a href="#val-new_typing_env" class="anchor"></a><code><span><span class="keyword">val</span> new_typing_env : <a href="#type-typing_env">typing_env</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_well_formed_type" class="anchored"><a href="#val-is_well_formed_type" class="anchor"></a><code><span><span class="keyword">val</span> is_well_formed_type : <span><a href="#type-typing_env">typing_env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p>Check whether a payload type is well-formed under the typing context</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ensure_satisfiable" class="anchored"><a href="#val-ensure_satisfiable" class="anchor"></a><code><span><span class="keyword">val</span> ensure_satisfiable : <span><a href="#type-typing_env">typing_env</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Validate whether the typing context is satisfiable, i.e. it does not contain in consistencies</p></div></div><div class="odoc-spec"><div class="spec value" id="val-env_append" class="anchored"><a href="#val-env_append" class="anchor"></a><code><span><span class="keyword">val</span> env_append : 
  <span><a href="#type-typing_env">typing_env</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Names/VariableName/index.html#type-t">Names.VariableName.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-typing_env">typing_env</a></span></code></div><div class="spec-doc"><p>Append an new entry into typing context</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_type" class="anchored"><a href="#val-check_type" class="anchor"></a><code><span><span class="keyword">val</span> check_type : <span><a href="#type-typing_env">typing_env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-payload_type">payload_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p>Check whether an expression can be assigned a provided type under a typing context</p></div></div><h2 id="smt-interfacing"><a href="#smt-interfacing" class="anchor"></a>SMT Interfacing</h2><div class="odoc-spec"><div class="spec type" id="type-smt_script" class="anchored"><a href="#type-smt_script" class="anchor"></a><code><span><span class="keyword">type</span> smt_script</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-add_assert_s_expr" class="anchored"><a href="#val-add_assert_s_expr" class="anchor"></a><code><span><span class="keyword">val</span> add_assert_s_expr : <span><a href="Sexp/index.html#type-t">Sexp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-smt_script">smt_script</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-smt_script">smt_script</a></span></code></div><div class="spec-doc"><p>Add an assertion into a SMT script</p></div></div><div class="odoc-spec"><div class="spec value" id="val-encode_env" class="anchored"><a href="#val-encode_env" class="anchor"></a><code><span><span class="keyword">val</span> encode_env : <span><a href="#type-typing_env">typing_env</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-smt_script">smt_script</a></span></code></div><div class="spec-doc"><p>Encode a typing context into a SMT script</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_sat" class="anchored"><a href="#val-check_sat" class="anchor"></a><code><span><span class="keyword">val</span> check_sat : <span><a href="#type-smt_script">smt_script</a> <span class="arrow">&#45;&gt;</span></span> <span>[ `Sat <span>| `Unsat</span> <span>| `Unknown</span> ]</span></span></code></div><div class="spec-doc"><p>Invoke SMT solver on an SMT script</p></div></div></div></body></html>